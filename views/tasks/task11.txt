Теперь давай сделаем уже наконец регистрацию.

1. Создаем страницу user/register. Она выводит форму регистрации. Минимум что нужно имейл и пароль. Если хочешь можешь еще чего хочешь добавить.

2. Когда форму сабмитят (жмут кнопку типа регистрируюсь или че там ты напишешь) то данные пользователя сохраняем в таблицу нашу user в бд.

3. После сохранения перенаправляем на нашу главную страницу (redirect делаем).

P.s. Форма понятное дело должна быть в рамках нашего дизайна общего. То есть шапка и футер остается как и на глваной ща, а между ними наша форма. Если не поймешь о чем я то я уточни уже в телеге.
Ща задания написал, особо не расписывая. Посмотрим как ты осилишь такой формат и заодно наделаешь кучу ошибок или не наделаешь, но я все равно потом расскажу что надо допилить или что и почему лучше сделать по другому.

----

В целом работает. Теперь надо учесть всякое.

1. Я ввожу в поле email не имейл и меня ргистрирует. Так быть не должно. Проверяем данные которые вводит пользователь. Юзаем регулярку (regexp)

2. То же самое с пустым паролем. Пароль не может быть пустым.

3. Касательно id и как ты его определяешь. Вытаскивая общий счет пользователей не очень надежно. Во первых если я удалю какого-то пользователя скажем с id 0, то их останется например 3, а у меня уже есть с id 3. То есть будет два пользователя с одинаковым id. Это приведет к плохим последствиям. Id должен быть уникальным. Более того надо запретить возможность хранить в таблице с одинаковым id. Смотерть в mysl что такое индексы, в частности primary. И что такое autoincrement и использовать это в таблице.

4. Касательно левого кода в даошке.

            echo '&ltscript&gtlocation.href= "/";&lt/script&gt';

Вот такой херни быть не должно. В плане не дело это дао куда-то чето принтить или редиректить. Дело дао просто создать пользователя, взаимодействовать с базой данных. Мы условились сами с собой что этот класс занимается только таким. Подобную логику реализовать в контроллере.

5. Как ты наверное заметил у нас есть дублирование кода создания подключения к бд.
 $dbh = new PDO('mysql:host=mymagaz.local;dbname=mymagaz', 'root', '', [
                \PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC
                , \PDO::MYSQL_ATTR_INIT_COMMAND => 'SET NAMES \'UTF8\''
            ]);
Более того у нас создается не одно подключение, что есть плохо. То есть мы на каждый запрос создаем свое подключение. Подключение что бы посчитать юзеров, подключение что бы вставить юзера. Потом еще чето будет. А создание подключеня к бд дело ресурсоемкое. Потому нам нужно что бы подключение к одному серверу бд ВСЕГДА в рамках запроса было одним.
Для этого нам нужно создать класс BaseDao. В нем по принципе сингильтона (мы когда-то делали) инициализировать подключение единожды по запросу к его методу connection(). Дальше все наши даохи наследуют этот класс. Читать что такое наследование классов в пхп.

6. Касательно методов конструкт и деструкт. Они вызываеются ВСЕГДА при создании и удалении обьекта. То есть ты ща прописал в контроллере там какой-то вывогд html. А допустим мне надо обратиться к методу контроллера и я не хочу что бы мне тот html выводило. Че мне делать? Или я хочу другой html. В общем не надо так делать. Более того надо вообще очень аккуратно относится к методу конструкт (про деструкт вообще забуть навсегда :)). Не пихать туда нихера без острой необходимости. Так как он вызывается ВСЕГДА при создании обьекта.

В общем убрать html оттуда и перенести в шаблон. Уже не раз говорил html держим отдельно в наших файлах view. Мы тоже так решили по принципу mvc что все что мы отображаем на экран мы храним в папке view в соответственных файлах.

7. Мне нравится что ты додумался выделить хедер и футер в отдельные файлы и инклудить их в одном месте. Это правильное решение. Но нужно его немножно усовершенствовать. Я обьясню почему. Мы с сайтом всегда общаемся через index.php, сейчас ты там рисуешь хедер и футер. Но нам не всегда будет нужно рисовать хедер и футер. Более того может быть что нам нужен другой хедер или футер итд.

Создаем папку view/layout, туда переносим наш хедер и футер. И теперь в наших вьюхах например в view/user/regiset.php или view/user/signin.php инклудим хедер и футер.

Да, мы так обязаны в каждом нашем шаблоне (так мы называем файлы в которых находится то что мы отображаем на экран, то что ниже папки view) инклудить хедер и футер. Тут можно сделать еще один уровень что бы каждый раз это не делать, но пока мы об этом забудем. Так что нужно переделать.


=====

Очередной апдейт по этой задаче. Прохожусь по предыдущей нумерации, отписываю результат.
Но прежде. Для удобства пользования пришло время познакомится с обозревателем бд. Я юзаю в основном phpmyadmin.
Можешь найти ссылку на него в меню Опенсервера web\images\tasks\2.png Я добавил скрин.
На этом же скрине видно как выглядит этот пхпмайадмин. Ну в общем заходишь по ссылке http://127.0.0.1/openserver/phpmyadmin/index.php и вводишь root без пароля. Там будут твои бд видно, таблицы. Думаю разберешься, если не то гугли.

1. По валидации данных. Посмотри на скрине какого пользователя я зарегал. Это не ок. Нагугли регексп по мылу и заюзай его. Учись и не бойся гуглить.
<div class = 're'> Вот я как раз и догуглился до того, что пользователь может напридумывать любой эмейл и так как почти везде используется подтверждение почты (то есть отправка письма на почту и переход оттуда по ссылке) не стоит тут включать паранойю ибо могут быть случаи когда пользователь не сможет зарегаться из-за лютой регулярки на мыло.
if (filter_var($_POST["email"], FILTER_VALIDATE_EMAIL)) - не пропускает кирилическое мыло.
</div>
Я хоть и давно работаю, но гуглю в рабочий день раз по 20 и постоянно юзаю наработанные решения. И еще обрати внимательно свой взор на то место где ты проверяешь пустое значение поля. Там есть ошибка. Связанная с методом емпти.
<div class = 're'>Хз о какой ты ошибке. Разве что о том, что интерпритатор php воспримет пароли - 0 как (целое число), и 0.0 как (дробное число). И в то же время метод empty воспримет это как пустое значение. Наверное тут лучше использовать метод isset. Гы, надо будет попроботь где-то зарегаться с паролем NULL )).</div>
И сразу сюда. Лучше не лениться, а проверять все данные отдельно. Рано или поздно тебе придется тыкать юзеру типа ошибка именно в мыле, ошибка именно в имени или в пароле.
<div class = 're'>Это не от лени. Думал так компактнее и проще для восприятия кода.</div>
2. Тут ок, про ошибку и разделение проверок полей писал выше.
3. Ок, прамари ключ поставил, автоинремент тоже. checkUser нужен, верно. Но мы сделали уникальным только мыло. Имя может быть одинаковым у людей. Так что переделай что бы только по мылу искало.
4. То что ты убрал то с дао верно. Теперь нужно редирект сделать не через js, а через пхп. Используй хедер. https://www.google.com/search?channel=trow2&client=firefox-b-d&q=%D1%81%D0%B4%D0%B5%D0%BB%D0%B0%D1%82%D1%8C+%D1%80%D0%B5%D0%B4%D0%B8%D1%80%D0%B5%D0%BA%D1%82+%D1%87%D0%B5%D1%80%D0%B5%D0%B7+%D0%BF%D1%85%D0%BF
<div class = 're'>Не могу я заставить хедер работать, потому и дошел до такой дичи как скрипт посреди ПХП. Перед ним же ничего не должно быть, а там и header.php и форма и еще всякое. ВО! )) Вот когда переделал как ты сказал - что бы вывод инфы был всегда в самом конце кода - и хедер заработал. Теперь при ошибке кенот хедер модификейшн сразу понимаю - где-то накосячил ))</div>
5. Хорошо, тут ок. Можно только не юзать parent::connection, а писать $this->connection(). Когда ты наследовал класс, то его методы сразу как бы и твои сразу.
6. Хорошо, убрал и отлично.
7. Давай стараться что бы у нас в контроллере всегда инклудилась только одна вьюха. То есть вот у тебя есть
А надо сделать  require_once '/../views/default/index.php';
А уже в этом файле, в этой вьюхе мы подключим и хедер, и футер, и отрисуем что нам тут надо
        require_once '/../views/layouts/header.php';
            &ltdiv class='container'>
            &ltli>&lta href = '/user/signin/'>SignIn&lt/a>&lt/li>
            &ltli>&lta href = '/user/register/'>Register&lt/a>&lt/li>
        require_once '/../views/layouts/footer.php';

Это же касается и в юзере сайни, реджистер. Мы не должны сначала чето эхать (хедер) потом чете делать и эхать футер.
Мы всегда стремимся эхать один раз в конце нашего исплонения кода (если нам надо чето эхать). И эхать какой-то пхп файл который мы называем вьювом.


Давай еще добавим в наш бейсдао вот такие методы. Подправь за надобностью чутка.

  public function GetAll($sql,$params = array(), $fetchMode = null)
    {
        //$stmt = $this->connection()->query($sql);
        $stmt = $this->connection()->prepare($sql);
        if ($this->Execute($stmt, $params)) {
            if ($fetchMode) {
                $result = $stmt->fetchAll($fetchMode);
            } else {
                $result = $stmt->fetchAll();
            }
            return $result;
        }
        return array();
    }

    public function GetRow($sql,$params = array())
    {
        //$stmt = $this->connection()->query($sql);
        $stmt = $this->connection()->prepare($sql);
        if ($this->Execute($stmt, $params)) {
            return $stmt->fetch();
        }
        return array();
    }

    public function GetOne($sql,$params = array())
    {
        $result = false;
        $stmt = $this->connection()->prepare($sql);

        if ($this->Execute($stmt, $params)) {
            $res = $stmt->fetch();
            $result = is_array($res) ? current($res) : $res;
        }

        return $result;
    }


    public function Prepare($sql)
    {
        $stmt = $this->connection()->prepare($sql);
        return $stmt;
    }

    public function quote($string)
    {
        return $this->connection()->quote($string);
    }

    public function Execute($sql,$params = array())
    {
        if ($sql instanceof PDOStatement) {
            $stmt = $sql;
        } else {
            $stmt = $this->connection()->prepare($sql);
        }
        $this->_lastStatement = $stmt;
        if ($stmt) {
            return $stmt->execute($params);
        }
        return false;
    }

    public function Insert_ID()
    {
        return $this->connection()->lastInsertId();
    }


Не надо каждый раз лепить эту конструкцию трай кетч. Она нам тут не нужна.
Когда ты запилиьшь эти методы ты сможешь вместо этого
 try {
            $dbh = parent::connection();

            $row = $dbh->query("SELECT * FROM users WHERE email = '$email' OR name = '$name'");
            return $row->fetch();
        } catch (PDOException $e) {
            echo $e->getMessage();
        }

Написать $row = $this->GetRow("SELECT * FROM users WHERE email = '$email' OR name = '$name'");
Что гораздо меньше места занимает, проще пишется и удобнее читается.


----

Не забудь поставить уник ключ в sql на мыло. Мы стараемся в бд всегда тоже учитывать что уникально. Так как в пхп можно где-то провтыкать проверить и нужно что бы в таком случае бд не дала сотворить неправильную (дублирующую) запись.
.

По следующей задаче мы будем делать авторизацию. Узнай что такое куки и сессия.
Сейчас у тебя есть какой-то там логин (actionSignIn). Я хочу что бы во время логина успешного в куку где-то записало имя входившего. И выводи потом из куки на экране в хедере привет, имя.
А в сессию записало дату входа. И выводи под именем дата входа: эта дата.