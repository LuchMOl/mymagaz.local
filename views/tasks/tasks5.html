<!DOCTYPE html>
<!--
To change this license header, choose License Headers in Project Properties.
To change this template file, choose Tools | Templates
and open the template in the editor.
-->
<html>
    <head>
        <title>Task 5</title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
    </head>
    <body>
        <ul>
            <li>1. Что за nbproject в папке web? У тебя что, проект в папке web имеет корень? Приложи скрин дерева проекта своего. Типа такого <img src="/img/5_0.png" width="250">
                <ul>
                    <li>1.1. Поправить если нужно что бы корень был в папке проэкта (родитель /web)</li>
                    <li>1.2. Почитать про файл .gitignore. Познакомиться с ним. Все что связанно с нетбинс не включаем в репозиторий. И вообще у тебя не должно быть физически в твоей папке /web/nbproject/ Иначе у тебя не правильно будет работать проект, и ты не получиш главных фич нетбинса. Я гляну потом по тимвьювер работает ли ок</li>
                    <li>1.3. Мне лениво каждый раз создавать тег картинки. Давай сделаем ImageService который будет фигачить это за меня.
                        <ul>
                            <li>1.3.1. Создать его</li>
                            <li>1.3.2. Для такого функционала я не хочу создавать обьект. Почитать про статические свойства и методы (static)</li>
                            <li>1.3.3. Создать статический метод getImgTag() Куда можно передавать параметры: имя изображения, расширение (по умолчанию делаем png, значение по-умолчанию задаем непосредственно в аргументе когда описываем метод), ширину (по умолчанию 250px), высоту (не обязательный аргумент)</li>
                            <li>1.3.4. Метод должен вернуть мне строку типа такой &lt;img src="/img/5_0.png" width="250"&gt;. То есть я даю методу имя файла и ехая результат у меня отрисует картинку сразу.</li>
                            <li>1.3.5. Внутри должен быть метод getImgFolderPath(). По-умолчанию он возвращает /img/. Он будет юзаться в нашем getImgTag поянтное дело.</li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>
                2. Ксательно задачи по упрщению getRoute в RouteService. <br>
                Ты там дописал вопросик про то всегда ли один маршрут. Ведь он меняется. <br>
                Отвечаю. Ты прав, маршрут меняется. Но не в рамках ондого запроса. Я помню что я долго этого почему-то не понимал, а когда понял то многе стало мне проще. Потому я еще раз заострю на этом месте внимание детальнее.<br>

                Как работает php? Проиходит запрос к серверу с определенным маршрутом. Например ввели в браузер /tasks/jopa/negra/. Апач посмотрел что запрос к пхп и запустил пхп. У нас зашло в index.php. В пхп переменной REQUEST_URI находится то что именно ввели в этом запросе "/tasks/jopa/negra/". Пхп обрабатывает этот запрос до конца, то есть у нас заканчивается исполнение всего что в index.php происходит и пхп отдает это в апач и апач шлет пользователю <br>
                Все. Все что произошло - мертво. Пхп не помнит предыдущих запросов, он выключился. <br>
                Теперь пользователь вводит /tasks/jopa/snejka/. И тут все проиходит так же, и в REQUEST_URI в рамках этого запроса всегда будет "/tasks/jopa/snejka/". Ну разве что ты сам запишешь в $_SERVER['REQUEST_URI'] = "что-то другое". Но зачем это делать? В этом нет смысла. Там как раз хранится путь запроса. <br>
                Допустим 10 пользователей одновремено нажали /tasks/jopa/negra/ и тут же нажали в другой вкладке /tasks/jopa/snejka/. Все равно все эти 20 запросов будут отдельно обрабатываться. У них своя жизнь, они ничего не знают друго про друга. Представь что запускается 20 отдеьлных программ пхп и они отдельно обрабатывают каждый свой запрос. То есть у всех свой $_SERVER, у всех свои переменные, классы. Они ничего друг о друге не знают. <br>
                Наша же задача что бы не парсило REQUEST_URI каждый раз когда идет вызов getRoute в РАМКАХ ОДНОГО ЗАПРОСА. То есть в index.php например может быть 20 вызовов getRoute(). И именно в рамках ОДНОГО ЗАПРОСА. <br>
                В общем у нас тут всегда будет один REQUEST_URI. Если вдруг не понял, то надо обсудить голосом еще. Это важная тема для понимания на мой взгляд, повторюсь
                <ul>
                    <li>Сейчас задача реализована некорректно. У тебя при каждом запросе getRoute() все равно доастает маршрут (в ифе).
                        <br>Повторюсь задача сама выдуманна мной. В ней нет реальной проблемы. Но что если бы explode('/', $_SERVER['REQUEST_URI']) выполнялось 5 сек? Тогда 2 вызова getRoute из index.php грузили бы наш сайт 10 сек, а не 5.
                    </li>
                    <li>
                        Попробуй переделать что бы explode выполянлся только первый запрос к getRoute.
                    </li>
                </ul>
            </li>
            <li>3. По taskService. Хорошо, реализовано корректно. Только давай немного спрячем реализацию логики. Зачем на в индексе перебор файлов, их вывод итд?
                <ul>
                    <li>3.1. Создаем метод renderTasksList(). Думаю по имени понятно что он должен делать. Переносим в него форич и эхаем списко файлов. В индексе просто его вызываем.</li>
                    <li>3.1.2 У нас не должно быть логики в индексе есть файл или нет его когда делаем getTask. Это дело taskService. В индексе просто вызов getTask. Проверку на наличие файла переносим в него же.
                    <li>getTask() не должен сразу выводить текст из файла. Он должен возвращать мне строку. И потом ее ехаем. Почему так? А может мне не надо выводить текст, а я его хочу отправить куда-то, или переписать в другой файл. Если бы я захотел что бы мне сразу написало что там в таске, я бы назвал метод renderTask</li>
                </ul>
            </li>
        </ul>

        <hr>
        <p>Даю две книги (они у мну есть печатные, потом тебе дам если надо будет), пока скачай в инете и по дороге на работу почитывай. <br>
            1. Р. Мартин Чистый код. Создание, анализ и рефакторинг https://rozetka.com.ua/ua/150330209/p150330209/?gclid=Cj0KCQjw0pfzBRCOARIsANi0g0vv0DktSJuin-lefG07UAxCoGz1ueT8zHinHMQrVkNUUAuTjAK4VboaAt23EALw_wcB<br>
            2. Мартин Фаулер Рефакторинг https://rozetka.com.ua/ua/40106032/p40106032/?gclid=Cj0KCQjw0pfzBRCOARIsANi0g0uWSmRa1igK1PmXJ6HFxMS0gdaw-3pPIxQa0r-rVKshOpTWfyHIR3MaAlPmEALw_wcB <br>

            Начинай с первой. Можно обе паралельно почитывать, если одна сильно утомляет. Они обе хорошие. В нашем деле главное научиться писать чистый код и уметь рефакторить грязый код в чистый (собсно то что ты ща будешь делать по третьему пункту это рефакторинг кода касающегося taskService). Но это реально <b>только по дороге (ну или там на работе если нехер делать минут 10-20 в день)</b>, зацикливаться на них не стоит. В целом может быть эти книги еще и рано, я хз. Но мож попробывать первую точно, как пойдет.
        </p>
    </body>
</html>
